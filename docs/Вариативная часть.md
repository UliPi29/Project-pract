# Создание простого текстового редактора на Python
## Введение
В данном документе описывается процесс создания простого текстового редактора на Python с использованием библиотеки `Tkinter`. Будет рассмотрена последовательность действий по исследованию предметной области, проектированию и реализации приложения.
## Исследование предметной области
### 1. Определение требований
#### 1.1 Основные функции текстового редактора:
* Ввод и редактирование текста.
* Сохранение текста в файл.
* Открытие существующих текстовых файлов.
* Изменение шрифта и стиля текста.
* Поддержка различных форматов файлов (например, .txt, .md).
* Возможность копирования, вставки и вырезания текста.
#### 1.2 Целевая аудитория:
* Пользователи, которым нужен простой текстовый редактор для заметок, программирования или редактирования текстовых файлов.
### 2. Основные типы данных
* **Строки(str):** Для хранения текста, введенного пользователем.
* **Списки (list):** Для хранения форматов файлов, поддерживаемых приложением.
* **Словари(dict):** Для хранения настроек шрифтов и других параметров интерфейса.
* **Файлы(file):** Для работы с текстовыми файлами (чтение и запись).
### 3. Анализ существующих решений
Изучение популярных текстовых редакторов, таких как:
* **Notepad:** Простой текстовый редактор с базовыми функциями.
* **Sublime Text:** Мощный редактор с поддержкой плагинов и расширенного редактирования.
* **Visual Studio Code:** Многофункциональный редактор с поддержкой языков программирования и интеграцией систем контроля версий.

## Техническое руководство
### Предварительные требования
* **Базовые знания в программировании на Python:** Понимание синтаксиса, переменных, функций и основных структур данных.
* **Установить Python версии 3 и выше:** Вы можете скачать последнюю версию Python с [официального сайта](https://www.python.org/).
* **Среда разработки:** Рекомендуется использовать PyCharm или любую другую удобную среду разработки, позволяющую работать с Python.
* **Встроенные модули Python:** Для работы с графическим интерфейсом мы будем использовать встроенный модуль tkinter.

(В данном руководсве в качестве среды разработки используется PyCharm, можно скачать с [официального сайта](https://www.jetbrains.com/pycharm/download/?section=windows))
### Создание технологии
#### 1. Создание проекта в PyCharm
* Для этого нажимаем `File` в верхней панели и из выпадающего списка выбираем `New Project`.
* В высветившемся окне прописываем путь и название проекта, на скриншотах `Project_for_pp`. После этого нажимаем кнопку `Create`.
* После этого на панели слева появятся файлы проекта и откроется автоматически созданный файл `main.py`(содержимое файла очистить).
![](https://github.com/UliPi29/Project-pract/blob/master/reports/photo/photo_5260733372051880436_y.jpg?raw=true)
#### 2. Импорт необходимых библиотек
В начале вашего файла добавьте следующие строки:
```
import sys
import tkinter as tk
from tkinter import filedialog, Menu
from tkinter import colorchooser
```
* `sys`: Модуль для взаимодействия с интерпретатором Python. В данном случае он может понадобиться для обработки аргументов командной строки, хотя в этом простом редакторе мы его не используем.
* `tkinter`: Библиотека для создания графических пользовательских интерфейсов (GUI) в Python.
* `filedialog`: Модуль для открытия диалогов выбора файлов, который позволяет пользователю выбирать файлы для открытия и сохранения.
* `Menu`: Класс для создания меню в приложении.
* `colorchooser`: Модуль для выбора цвета, который позволяет пользователю выбирать цвет для текста и фона.
####  3. Создаем функцию для сохранения файла
Теперь добавим функцию, которая будет обрабатывать сохранение текста в файл:
```
def saveas():
    t = text.get("1.0", "end-1c")
    savelocation = filedialog.asksaveasfilename(defaultextension=".txt",
                                                 filetypes=[("Text files", "*.txt"), ("All files", "*.*")])
    if savelocation:
        with open(savelocation, "w") as file:
            file.write(t)
```
* `text.get("1.0", "end-1c")`: Извлекает текст из текстового поля, начиная с первой строки и до конца (включая все символы).
* `filedialog.asksaveasfilename(...)`: Открывает диалоговое окно для сохранения файла, позволяя пользователю выбрать имя и место.
* `with open(savelocation, "w") as file`: Открывает файл для записи. Использование `with` гарантирует, что файл будет закрыт после завершения работы с ним.
#### 4. Создаем функции для изменения шрифта
Устанановим шрифт Helvetica размером 12:
```
def FontHelvetica():
    text.config(font=("Helvetica", 12))
```
Аналогично создадим функции еще для нескольких шрифтов (например, Courier, Arial, Times New Roman, Comic Sans MS)
```
def FontCourier():
    text.config(font=("Courier", 12))

def FontArial():
    text.config(font=("Arial", 12))

def FontTimesNewRoman():
    text.config(font=("Times New Roman", 12))

def FontComicSans():
    text.config(font=("Comic Sans MS", 12))
```
#### 5. Создадим функции для изменения цвета
```
def change_bg_color():
    color = colorchooser.askcolor(title="Choose Background Color")[1]
    if color:
        text.config(bg=color)

def change_fg_color():
    color = colorchooser.askcolor(title="Choose Text Color")[1]
    if color:
        text.config(fg=color)
```
* `colorchooser.askcolor()`: Это метод из модуля `tkinter.colorchooser`, который открывает диалоговое окно для выбора цвета. Метод возвращает кортеж, где первый элемент — это RGB-значение цвета, а второй элемент — строка с шестнадцатеричным представлением цвета (например, #FFFFFF для белого). Мы используем `[1]`, чтобы получить именно это шестнадцатеричное значение.
* `text.config(bg=color)`: Метод `config()` используется для изменения свойств виджета. Здесь мы изменяем фон текстового поля `(bg)` на выбранный цвет.
* `change_fg_color()`: Структура этой функции аналогична функции `change_bg_color()`. Мы снова используем `colorchooser.askcolor()` для выбора цвета. В этом случае мы изменяем цвет текста `(fg)` текстового поля на выбранный цвет.
#### 6. Создадим функцию для очистки текста
```
def clear_text():
    text.delete("1.0", tk.END)
```
* `text.delete("1.0", tk.END)`: Удаляет текст, начиная с первой строки до конца текстового поля.
#### 7. Создаем главное окно
Теперь создадим главное окно вашего текстового редактора:
```
root = tk.Tk()
root.title("Text Editor")
root.geometry("600x700")
```
* `tk.Tk()`: Создает основное окно приложения.
* `title("Text Editor")`: Устанавливает заголовок окна.
* `geometry("600x700")`: Устанавливает размер окна (ширина x высота).
#### 8. Создаем текстовое поле
Добавим текстовое поле, где пользователи смогут вводить текст:
```
text = tk.Text(root, padx=10, pady=10)
text.pack(expand=True, fill='both')
```
* `tk.Text(root)`: Создает текстовое поле, которое будет содержаться в основном окне `root`.
* `padx` и `pady`: Эти параметры добавляют отступы внутри текстового поля, чтобы текст не прилипал к краям.
* `pack(expand=True, fill='both')`: Использует менеджер размещения `pack`, чтобы текстовое поле занимало доступное пространство в окне.
####  9. Создаем кнопку для сохранения
Добавим кнопку, которая будет вызывать функцию сохранения:
```
button = tk.Button(root, text="Save", command=saveas, height=2, width=10)
button.pack(side='bottom', pady=5)
```
* `tk.Button(...)`: Создает кнопку с текстом "Save" и связывает ее с функцией `saveas`.Параметры `height` и `width` задают размеры кнопки.
* `pack(side='bottom')`: Размещает кнопку внизу окна.
#### 10. Создаем кнопку для очистки текста
Аналогично кнопке "Save", создадим кнопку, которая очищает весь текст при нажатии:
```
clear_button = tk.Button(root, text="Clear", command=clear_text, height=2, width=10)
clear_button.pack(side='bottom', pady=5)
```
#### 11. Создаем строку состояния
```
status_bar = tk.Label(root, text="Character count: 0", bd=1, relief=tk.SUNKEN, anchor='w')
status_bar.pack(side='bottom', fill='x')
```
* `tk.Label`: Создает метку, которая будет отображать количество символов в текстовом поле.
* `bd=1`: Задает ширину границы.
* `relief=tk.SUNKEN`: Задает стиль границы.
* `anchor='w'`: Указывает выравнивание текста по левому краю.
#### 12. Функция для обновления строки состояния
```
def update_status_bar(event=None):
    char_count = len(text.get("1.0", "end-1c"))
    status_bar.config(text=f"Character count: {char_count}")

text.bind("<KeyRelease>", update_status_bar)
```
* `text.get("1.0", "end-1c")`: Получает текст из текстового поля, чтобы подсчитать количество символов.
* `text.bind("<KeyRelease>", update_status_bar)`: Привязывает событие отпускания клавиши к функции, которая обновляет строку состояния.
#### 13. Создаем меню для выбора шрифта
Теперь добавим меню, чтобы пользователи могли выбирать шрифт:
```
font_menu = Menu(root)
root.config(menu=font_menu)

font_submenu = Menu(font_menu, tearoff=0)
font_menu.add_cascade(label="Font", menu=font_submenu)

font_submenu.add_command(label="Helvetica", command=FontHelvetica)
font_submenu.add_command(label="Courier", command=FontCourier)
font_submenu.add_command(label="Arial", command=FontArial)
font_submenu.add_command(label="Times New Roman", command=FontTimesNewRoman)
font_submenu.add_command(label="Comic Sans MS", command=FontComicSans)
```
* `Menu(root)`: Создает основное меню для главного окна.
* `root.config(menu=font_menu)`: Присоединяет созданное меню к главному окну.
* `Menu(font_menu, tearoff=0)`: Создает подменю для выбора шрифта. Параметр `tearoff=0` отключает возможность отделения подменю от основного меню.
* `add_cascade(...)`: Добавляет подменю к основному меню.
* `add_command(...)`: Добавляет пункты меню, которые вызывают соответствующие функции для изменения шрифта текстового поля.
#### 14. Создаем подменю для изменеия цвета
Теперь добавим подменю для изменеия цвета фона и текста:
```
color_menu = Menu(font_menu, tearoff=0)
font_menu.add_cascade(label="Color", menu=color_menu)
color_menu.add_command(label="Change Background Color", command=change_bg_color)
color_menu.add_command(label="Change Text Color", command=change_fg_color)
```
* `color_menu.add_command`: Добавляет команды для изменения цвета фона и текста, которые вызывают соответствующие функции.
#### 15. Запускаем главный цикл приложения
В конце файла добавьте строку, чтобы запустить главный цикл приложения:
```
root.mainloop()
```
* `root.mainloop()`: Запускает главный цикл приложения, который обрабатывает события и обновляет интерфейс. Это необходимо для того, чтобы окно оставалось открытым и реагировало на действия пользователя.
## Модификации
При создании своего текстового редактора, я использовала [данную инструкцию](https://www.instructables.com/Create-a-Simple-Python-Text-Editor/), однако код, приведенный там, неактулен для среды разработки PyCharm, из-за чего оказался нерабочим.
Поэтому мной были осуществленны следующие изменения:
* Убрана зависимость от версии Python. Предполагается, что используется Python 3, что упрощает код.
* Импорт `filedialog` вместо `tkFileDialog`, что соответствует стандартам Python 3.
* В коде, приведенном на сайте, заголовок окна устанавливается следующим образом:
  ```
  root=Tk("Text Editor")
  ```
  что является неверным. Вместо той строки следует написать:
  ```
  root = Tk()
  root.title("Text Editor")  
  ```
* В моем коде вместо `grid()` используется `pack()` с параметрами `expand` и `fill`, что позволяет текстовому полю занимать доступное пространство.
* Использование `filedialog` вместо `tkFileDialog`.
* Проверка на `None` для `savelocation`, чтобы избежать ошибок при отсутствии выбора.
* Использование контекстного менеджера `with`, что автоматически закрывает файл после записи.
* Использование `Menu` вместо `Menubutton`, что является более стандартным подходом для создания меню.
* Добавлено еще несколько видов шрифтов.
* Добавлены функции для изменеия фона редактора и цвета текста.
* Убраны ненужные переменные `IntVar()`, так как для простого выбора шрифта это не требуется.
* Упрощение добавления пунктов меню с помощью `add_command`, что делает код более читабельным.
* Добавлена строка состояния, которая отображает количество символов, что улучшает интерфейс и делает его более информативным.
* Добавлена функция `update_status_bar`, которая обновляет строку состояния при каждом нажатии клавиши.
* Используется метод `text.get("1.0", tk.END)` для получения текста из текстового поля. `-1` используется, чтобы исключить символ конца строки, который добавляется автоматически.
* Строка состояния обновляется с помощью метода `config`, чтобы отобразить текущее количество символов.
* Привязка события `<KeyRelease>` к текстовому полю, чтобы функция `update_status_bar` вызывалась каждый раз, когда пользователь отпускает клавишу. Это позволяет динамически обновлять информацию о количестве символов в строке состояния.
